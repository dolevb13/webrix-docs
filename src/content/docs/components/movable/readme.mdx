import {Example} from 'components';

The `<Movable/>` component can be used to create elements that the user can move.

As opposed to a draggable element, the `<Movable/>` component does not require a source/target configuration.
Instead, it supports 3 custom events (`onBeginMove`, `onMove`, `onEndMove`) through which you can control the movement.

The `<Movable/>` also comes with a set of hooks for reduced boilerplate and easy constraint application.
Constraints are used for controlling the way an element is moved.
You can use one of the pre-defined constraints, or create your own.

## Basic Example

<Example file='docs/components/movable/BasicExample' height={200}/>

In this example we are using the `Movable.useMove()` hook to control the movement.
The `onMove` callback is called when the element moves, passing an object with `top/left`
as an argument.

## Constraints

### Constraint Axis

<Example file='docs/components/movable/ConstraintAxis' height={200}/>

The `<Movable/>` component gives you complete control over the positioning of the element by only passing information
through the event without actually manipulating the element itself.
This way you are free to add your own logic and constraints.

In this example, we ignore the movement of the mouse on the `x` axis to constraint the element to the `y`
axis. We do that by only applying the `top` value of the position.

### Snapping

<Example file='docs/components/movable/Snapping' height={200}/>

Similarly to the previous example, more complex constraints can be applied using the provided
constraints in `Movable.Constraints`.

In the example above we're using the `Movable.Constraints.snap(horizontal, vertical, strength)`
constraint to make the movable element snap to a 20px by 20px grid.

<Example file='docs/components/movable/SnappingAdvanced' height={300}/>

In this example you can see how to apply different gird sizes and different snap strengths.

### Contain

<Example file='docs/components/movable/Contain' height={300}/>

In this example we're using the `Movable.Constraints.contain(container)` constraint, to limit the movement
of the element within the boundaries of the given container.

### Mixing Constraints

<Example file='docs/components/movable/Mixing' height={300}/>

In this example we're combining 2 different constraints to achieve a more complex behavior.
You can mix as many constraints as you need, but for optimal UX you will need to make sure
that the constraints make sense when applied together.

### Custom Constraints

<Example file='docs/components/movable/CustomConstraints' height={300}/>

You can create your own custom constraints using the `Movable.createConstraint()` function.
This function takes an object with the Movable's events (i.e. `onBeginMove`, `onMove` and `onEndMove`).

In this example, we create a custom constraint called `snapClass`, that adds the given CSS class to the element when it
is snapped to the given grid.

Each Movable event receives 3 arguments:

* The original event object.
* The set of arguments that were passed to the hook (in the example we extract `ref` from it).
* An object with the data shared between events/constraints.

You can pass data between events by mutating the 3rd argument, which is an object that is shared between all
the events, and across constraints. This argument also contains a `next` key, where you should store
the next Movable coordinates (in the above example we extract `next` from it to determine whether it will
be on the grid after all constraints are applied).

## Movable Area

<Example file='docs/components/movable/MovableArea' height={300}/>

Until now we've been using the `Movable.useMove()` hook to move the element by clicking on it
and dragging it. However, in certain cases you don't want to click on the element, but rather on
the point you wish the element to move to (for example, in sliders).

For that you can use the `Movable.useMoveArea()` hook, as seen in the example above.
Click anywhere inside the dashed box to make the red circle move to that point.
Click & drag anywhere inside the dashed box to make the red circle follow the cursor.

## Custom Handlers

<Example file='docs/components/movable/Manual' height={200}/>

If you need some custom behavior that you cannot get using the `Movable` hooks, you can write your
own event handlers. When a user moves a `<Movable/>` element, the custom events (`onBeginMove`, `onMove`, `onEndMove`)
are triggered, passing the mouse position (`x/y`), the difference in the coordinates since the beginning of the event
(`dx/dy`), and the difference in the coordinates since the last event (`cx/cy`) as arguments.

In this example we are using the change in coordinates (`cx/cy`) for updating the `position` state.

Notice that we are using a function to set the state, instead of passing an object directly.
This is because the [state may be updated asynchronously](https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous),
so we cannot rely on the state value for calculating the next position.

Using a function will give us the previous state as an argument, and we can use that to accurately calculate the
next position.

<Example file='docs/components/movable/ManualAdvanced' height={200}/>

You can avoid the issue explained above, and get a more user-friendly movement
by using the deltas (`dx/dy`) or the mouse position (`x/y`).
However, using them requires maintaining the initial position of the element as soon as the movement begins.
This can be done through the `onBeginMove` event, as can be seen in the above example.

## API

### Importing

```jsx
// ESM
import {Movable} from 'webrix/components';
import Movable from 'webrix/components/Movable'; // For better tree shaking

// UMD
const {Movable} = Webrix.components;
```

### Props

Name|Type|Default|Description
---|---|---|---
`onBeginMove`|function|`() => null`|Specifies a callback to be called when the user begins to move the element
`onMove`|function|`() => null`|Specifies a callback to be continuously called as the user moves the element around. Receives `x/y/dx/dy/cx/cy` as arguments (see description above for more info)
`onEndMove`|function|`() => null`|Specifies a callback to be called when the user stops moving the element

### Hooks

#### `Movable.useMove({ref, onMove, constraints = []})`

Generate the set of props to be injected to a `<Movable/>` component, applying the given constraints.

#### `Movable.useMoveArea({ref, onMove, constraints = []})`

Generate the set of props to be injected to a Movable component, applying the given constraints.
This is similar to useMove(), only here the ref is used as a movement 'pad', and the movement
is usually applied to another element.

### Constraints

#### `Movable.Constraints.snap(horizontal, vertical, strength = 1)`

Snap the movement to a grid specified by the given `horizontal` & `vertical` sizes
of the grid steps, optionally specifying the snapping strength in `strength`, as a number between `0` and `1`.

#### `Movable.Constraints.contain(container)`

Limit the movement to the bounding rect of the given container.

#### `Movable.Constraints.padding(top, right, bottom, left)`

Apply padding to the movement boundaries.
This can either be the bounds specified by the `contain()` constraint,
or, if using the `useMoveArea()` hook, the bounding rect of the given ref.

#### `Movable.createConstraint(...)`

Create a custom constraint to be passed to the `constraints` argument. See [Custom Constraints](#constraints-custom-constraints) above
for additional info.